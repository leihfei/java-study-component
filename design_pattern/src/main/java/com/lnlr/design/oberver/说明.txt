观察者模式：
    定义了对象之间一对多的依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到
    通知并自动更新。

 项目说明：
    manual 包
        天气主题(Subject) ，subject是一个接口
            注册观察者，注销观察者，推送数据等
        观察者(Observer),observer 是一个接口
            包含一个更新update接口
        显示接口(DisplayElement),是一个接口
            就只包含了一个display方法
    在当前看板中，注册一个主题，再把当前看板作为一个观察者注册到主题中，那么主题中就包含了该观察者，
    那么在更新主题的时候循环调用了观察者的update方法更新观察者中的数据，从而进行显示。

    使用java.util下的包
    Observable（class），是一个类，类中维护一个Vector的向量，线程安全，还有一个chenged，是用于判断是
    推送，还是观察者自动拉取。

    Observer（interface),是一个接口，只有一个update方法，参数为(Observable,Object)

    我们事先气象站的时候，必须在设置气象值之后进行手动调用notifyObservers(org)方法，这样就可以就行数据推送
    到了看板。
    在看板中实现接口，并且将看板(this)注册到气象站中,这样同一个气象站对象就拥有了观察者对象。
    那么在主题需要推送数据的时候，观察者就可以得到数据了。


 在Observable类中，线程安全


观察者模式要点：
    观察者模式定义了对象之间的一对多关系

    主题：也就是克观察者用一个共同的接口来更新观察者
    观察者和可观察者之间用送耦合方式结合（loosecoupling),可观察者不知道观察者的细节，只知道观察者实现了观察者接口。

    使用此模式时：你可从被从观察者出推(push)或拉(pull)数据(然而，推的方式被认为更正确)
    有多个观察者时，不可以依赖特定的顺序的通知次序

    Java有多个观察者模式的实现，包括了通用的java.utils.Observable

    要注意java.util.Observable实现带来的一些问题(Observable是类)

    如果有必要的话，可以实现自己的Observable，并不困难。

    Swing大量使用观察者模式，许多GUI框架也是如此。






使用场合：
    定报纸 -> 出版社（主题） + 订阅者（观察者） = 观察者模式
    送牛奶 -> 牛奶厂 + 定奶者 = 观察者模式
    JaveBeans,RMI



